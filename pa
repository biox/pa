#!/bin/sh
#
# pa - a simple password manager

pw_add() {
    if ask "generate a password? [y/N]" N; then
        pass=$(rand_chars "${PA_LENGTH:-50}" "${PA_PATTERN:-A-Za-z0-9-_}")

        [ "$pass" ] ||
            die "couldn't generate a password"
    else
        # 'sread()' is a simple wrapper function around 'read'
        # to prevent user input from being printed to the terminal.
        sread pass "enter a password"

        [ "$pass" ] ||
            die "password can't be empty"

        sread pass2 "enter a password (again)"

        # Disable this check as we dynamically populate the two
        # passwords using the 'sread()' function.
        # shellcheck disable=2154
        [ "$pass" = "$pass2" ] ||
            die "passwords don't match"
    fi

    mkdir -p "$(dirname "./$name")" ||
        die "couldn't create category '$(dirname "./$name" | cut -c3-)'"

    # Use 'age' to store the password in an encrypted file.
    # A heredoc is used here instead of a 'printf' to avoid
    # leaking the password through the '/proc' filesystem.
    #
    # Heredocs are sometimes implemented via temporary files,
    # however this is typically done using 'mkstemp()' which
    # is more secure than a leak in '/proc'.
    $age --encrypt -R "$recipients_file" -o "./$name.age" <<-EOF ||
		$pass
	EOF
        die "couldn't encrypt $name.age"

    printf '%s\n' "saved '$name' to the store."

    if $git_enabled; then git_add_and_commit "./$name.age" "add '$name'"; fi
}

pw_edit() {
    new=true edittmp=$(mkstemp) ||
        die "couldn't create a shared memory filename"

    trap 'rm -f "$edittmp"' EXIT

    [ -f "$name.age" ] && new=false &&
        { $age --decrypt -i "$identities_file" -o "$edittmp" "./$name.age" ||
            die "couldn't decrypt $name.age"; }

    ${EDITOR:-vi} "$edittmp" ||
        die "editor exited unsuccessfully"

    [ -s "$edittmp" ] || return

    mkdir -p "$(dirname "./$name")" ||
        die "couldn't create category '$(dirname "./$name" | cut -c3-)'"

    $age --encrypt -R "$recipients_file" -o "./$name.age" "$edittmp" ||
        die "couldn't encrypt $name.age"

    if $new; then printf '%s\n' "saved '$name' to the store."; fi

    if $git_enabled; then git_add_and_commit "./$name.age" "edit '$name'"; fi
}

pw_del() {
    ask "delete password '$name'? [y/N]" N || return

    rm -f "./$name.age"

    rmdir -p "$(dirname "./$name")" 2>/dev/null || :

    if $git_enabled; then git_add_and_commit "./$name.age" "delete '$name'"; fi
}

pw_show() {
    $age --decrypt -i "$identities_file" "./$name.age" ||
        die "couldn't decrypt $name.age"
}

pw_list() {
    find "./$name" -type f -name \*.age | sed 's/..//;s/\.age$//' | sort
}

change_recipients() {
    cmp -s "$recipients_file" .recipients && return

    [ -f "$PA_DIR/lock" ] &&
        die "locked to change recipients"

    new_local=false revoke=false new_count=0 old_count='' passtmp=$(mkstemp) ||
        die "couldn't create a shared memory filename"

    # Compare recipients files to transfer new locally added recipients.
    grep -Fxvf .recipients "$recipients_file" >"$passtmp" && new_local=true

    trap 'rm -f "$passtmp" "$PA_DIR/lock"' EXIT

    # Compare recipients files to transfer new remotely added recipients.
    if new_remote=false && grep -Fxvf "$recipients_file" .recipients >&2 &&
        new_remote=true && ! ask "do you trust these recipients? [y/N]" N; then
        old_count=$(wc -l <.recipients)
        cp "$recipients_file" .recipients
    elif $new_local; then
        cat "$passtmp" >>.recipients
    elif $new_remote; then
        new_count=$(wc -l <.recipients)
    # No new recipients means only their order
    # is different, so no need to re-encrypt.
    else
        cp .recipients "$recipients_file"

        return
    fi

    total=$(pw_list | nl -w 1 | tee "$PA_DIR/lock" | tail -n 1 | cut -f 1)

    # Try to re-encrypt all passwords
    # for new recipients.
    while read -r i passname; do
        count=$(grep -c '^-> ' "./$passname.age")

        # Compare the number of recipient stanzas in the encrypted password file
        # with the number of remote recipients to not duplicate re-encryption of
        # passwords as it might have already been done on another device.
        [ "$new_count" -eq "$count" ] && continue

        # Check if file was encrypted to removed recipients.
        [ "$old_count" ] && [ "${old_count:-0}" -le "$count" ] && revoke=true

        # Skip re-encryption of file that isn't encrypted to removed recipients.
        [ "$old_count" ] && ! $new_local && ! $revoke && continue

        [ -t 2 ] && printf 're-encrypting password %d of %d\r' "$i" "$total" >&2

        $age --decrypt -i "$identities_file" "./$passname.age" 2>/dev/null |
            $age -R .recipients -o "$passtmp" && mv "$passtmp" "./$passname.age"
    done <"$PA_DIR/lock"

    # To prepare for next output, use spaces to clean up the progress
    # line, which has 27 non-digits and 2 numbers (current and total).
    [ -t 2 ] && [ "$total" ] && printf '%*s\r' "$((${#total} * 2 + 27))" "" >&2

    cp .recipients "$recipients_file"

    [ "$old_count" ] && [ "${total:-0}" -gt 0 ] && if $revoke; then
        printf '\n%s\n' "recipients were revoked, but holders of
corresponding identities are still able
to decrypt old copies of password files." >&2

        [ -d .git ] && find .git ! -name config -type f -exec rm -f {} + &&
            printf '%s\n' "repo is recreated to avoid leaks." >&2

        printf '%s\n\n' "YOU SHOULD CHANGE YOUR PASSWORDS!" >&2
    else
        printf '\n%s\n\n' "the remote you sync with tried to
add untrusted recipients, to stop
it you should set another remote!" >&2
    fi

    # Only try to commit if there are any untracked files or unstaged changes.
    if $git_enabled && git init -q && git status --porcelain | grep -q .; then
        git_add_and_commit . "change recipients"
    fi
}

git_add_and_commit() {
    git add "$1" && git commit -qm "$2"
}

mkstemp() {
    # Prefer /dev/shm because it's an in-memory
    # space that we can use to store data without
    # having bits laying around in sectors.
    # Fall back to /tmp - /dev/shm is Linux-only & /tmp
    # and shared memory space on other operating systems
    # have non-standard methods of setup/access.
    if [ -w /dev/shm ]; then tmpdir=/dev/shm; else tmpdir=/tmp; fi

    suffix=$(rand_chars 10 'A-Za-z0-9')

    [ "$suffix" ] || return

    printf "$tmpdir/pa.%s" "$suffix"
}

rand_chars() {
    # Generate random characters by reading '/dev/urandom' with the
    # 'tr' command to translate the random bytes into a
    # configurable character set.
    #
    # The 'dd' command is then used to read only the desired length.
    #
    # Regarding usage of '/dev/urandom' instead of '/dev/random'.
    # See: https://www.2uo.de/myths-about-urandom
    #
    # $1 = number of chars to receive
    # $2 = filter for the chars
    LC_ALL=C tr -dc "$2" </dev/urandom | dd ibs=1 obs=1 count="$1" 2>/dev/null
}

ask() {
    printf '%s: ' "$1" >&2

    # Enable raw input to allow for a single byte to be read from
    # stdin without needing to wait for the user to press Return.
    [ -t 0 ] && stty -echo -icanon

    # Read a single byte from stdin using 'dd'. POSIX 'read' has
    # no support for single/'N' byte based input from the user.
    answer=$(dd ibs=1 count=1 2>/dev/null)

    # Disable raw input, leaving the terminal how we *should*
    # have found it.
    [ -t 0 ] && stty echo icanon

    printf '%s\n' "${answer:-$2}" >&2

    # Handle the answer here directly, enabling this function's
    # return status to be used in place of checking for '[yY]'
    # throughout this program.
    glob "$answer" '[yY]'
}

sread() {
    printf '%s: ' "$2" >&2

    # Disable terminal printing while the user inputs their
    # password. POSIX 'read' has no '-s' flag which would
    # effectively do the same thing.
    [ -t 0 ] && stty -echo
    read -r "$1"
    [ -t 0 ] && stty echo

    printf '\n' >&2
}

glob() {
    # This is a simple wrapper around a case statement to allow
    # for simple string comparisons against globs.
    #
    # Example: if glob "Hello World" '* World'; then
    #
    # Disable this warning as it is the intended behavior.
    # shellcheck disable=2254
    case $1 in $2) return 0 ;; esac
    return 1
}

die() {
    printf '%s: %s.\n' "$(basename "$0")" "$1" >&2
    exit 1
}

usage() {
    printf %s "\
  pa
    a simple password manager

  commands:
    [a]dd  [name] - Add a password entry.
    [d]el  [name] - Delete a password entry.
    [e]dit [name] - Edit a password entry with ${EDITOR:-vi}.
    [g]it  [cmd]  - Run git command in the password dir.
    [l]ist [cat]  - List all entries in a category.
    [s]how [name] - Show password for an entry.

  env vars:
    data directory:   export PA_DIR=~/.local/share/pa
    password length:  export PA_LENGTH=50
    password pattern: export PA_PATTERN=A-Za-z0-9-_
    disable tracking: export PA_NOGIT=
"
    exit 0
}

main() {
    age=$(command -v age || command -v rage) ||
        die "age not found, install per https://age-encryption.org"

    : "${PA_DIR:=${XDG_DATA_HOME:-$HOME/.local/share}/pa}"

    glob "$PA_DIR" '/*' ||
        die "PA_DIR must be an absolute path (got '$PA_DIR')"

    identities_file=$PA_DIR/identities
    recipients_file=$PA_DIR/recipients

    mkdir -p "$PA_DIR/passwords" ||
        die "couldn't create pa directories"

    cd "$PA_DIR/passwords" ||
        die "couldn't change to password directory"

    # Ensure that we leave the terminal in a usable state on Ctrl+C.
    [ -t 0 ] && trap 'stty echo icanon; trap - INT; kill -s INT 0' INT

    [ ! -s "$identities_file" ] || [ ! -s "$recipients_file" ] && r='' && {
        y= && command -v age-plugin-yubikey >/dev/null && y='[y]ubikey/'
        s= && command -v age-plugin-se >/dev/null && s='[s]e/'
        t= && command -v age-plugin-tpm >/dev/null && t='[t]pm/'
        { ! command -v age-keygen && command -v rage-keygen; } >/dev/null && r=r

        [ -s "$identities_file" ] || if [ "$y" ] || [ "$s" ] || [ "$t" ] &&
            printf "choose identity generator (" >&2 &&
            ask "$y$s$t${r}age-keygen)" && [ "$y" ]; then
            age-plugin-yubikey -g --name "pa identity" --pin-policy never
        elif [ "$s" ] && glob "$answer" [sS]; then
            age-plugin-se keygen 2>/dev/null
        elif [ "$t" ] && glob "$answer" [tT]; then
            age-plugin-tpm --generate
        else
            "${r}age-keygen" 2>/dev/null
        fi >"$identities_file" ||
            die "couldn't generate an identity"

        grep -q ^AGE-PLUGIN-YUBIKEY- "$identities_file" &&
            # Get recipients only for keys in identities file.
            age-plugin-yubikey -i 2>/dev/null | awk 'FNR==NR&&$0&&!/^#/{a[$0]
            next}$0 in a{print p}{p=$NF}' "$identities_file" -

        grep -q ^AGE-PLUGIN-SE- "$identities_file" &&
            grep ^AGE-PLUGIN-SE- "$identities_file" | age-plugin-se recipients

        grep -q ^AGE-PLUGIN-TPM- "$identities_file" &&
            grep ^AGE-PLUGIN-TPM- "$identities_file" | age-plugin-tpm -y

        grep -q ^AGE-SECRET-KEY- "$identities_file" &&
            grep ^AGE-SECRET-KEY- "$identities_file" | "${r}age-keygen" -y
    } >>"$recipients_file"

    [ -s "$recipients_file" ] ||
        die "couldn't generate recipients"

    [ -f .recipients ] || cp "$recipients_file" .recipients

    git_enabled=false
    [ -z "${PA_NOGIT+x}" ] && command -v git >/dev/null && git_enabled=true

    $git_enabled && [ ! -d .git ] && {
        git init -q

        git config pull.rebase false

        # Put something in user config if it's not set globally,
        # because git doesn't allow to commit without it.
        git config user.email >/dev/null ||
            git config user.email "${EMAIL:-$(id -un)@$(uname -n)}"

        # Configure diff driver for age encrypted files that treats them as
        # binary and decrypts them when a human-readable diff is requested.
        git config diff.age.binary true
        git config diff.age.textconv "$age --decrypt -i '$identities_file'"

        # Always prefer our version of
        # files after merge conflicts.
        git config merge.ours.driver true

        printf '%s\n' "*.age diff=age merge=ours
.gitattributes merge=union
.recipients merge=union" >.gitattributes

        git_add_and_commit . "initial commit" ||
            die "couldn't create initial commit"
    }

    command=$1
    shift

    glob "$command" 'g*' && {
        git "$@" && change_recipients
        exit $?
    }

    # Combine the rest of positional arguments into
    # a name and remove control characters from it
    # so that a name can always be safely displayed.
    name=$(printf %s "$*" | LC_ALL=C tr -d '[:cntrl:]')

    glob "$command" '[ades]*' && [ -z "$name" ] &&
        die "missing [name] argument"

    glob "$command" '[ades]*' && { glob "$name" '/*' || glob "$name" '*/'; } &&
        die "name can't start or end with '/'"

    glob "$command" 'l*' && glob "$name" '/*' &&
        die "category can't start with '/'"

    glob "$name" '../*' || glob "$name" '*/../*' &&
        die "category went out of bounds"

    glob "$command" 'a*' && [ -f "$name.age" ] &&
        die "password '$name' already exists"

    glob "$command" '[ds]*' && [ ! -f "$name.age" ] &&
        die "password '$name' doesn't exist"

    glob "$command" 'l*' && [ "$name" ] && [ ! -d "$name" ] &&
        die "category '$name' doesn't exist"

    name='' change_recipients

    case $command in
    a*) pw_add ;;
    d*) pw_del ;;
    e*) pw_edit ;;
    l*) pw_list ;;
    s*) pw_show ;;
    *) usage ;;
    esac
}

# Ensure that debug mode is never enabled to
# prevent the password from leaking.
set +x

# Ensure that globbing is disabled
# to avoid insecurities with word-splitting.
set -f

# Ensure that pipelines return status of the
# last failed command.
set -o pipefail

# Restrict permissions of any new files to
# only the current user.
umask 077

[ "$1" ] || usage && main "$@"
